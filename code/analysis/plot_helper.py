import matplotlib
matplotlib.use('Agg')
import matplotlib.gridspec as gridspec
import pylab as plt
import helper as hf
import numpy as np
import matplotlib.mlab as mlab
import json
import ijson
import os
import seaborn as sns

def set_box_color(bp, color):
    """
    recolor boxplots generated by sns.boxplot
    Args:
        bp: the box of a boxplot that is to be recolored
        color: the preferred color

    """
    plt.setp(bp['boxes'], color=color)
    plt.setp(bp['whiskers'], color=color)
    plt.setp(bp['caps'], color=color)
    plt.setp(bp['medians'], color=color)

def latexify(fig_width=None, fig_height=None, columns=1):
    """Set up matplotlib's RC params for LaTeX plotting.
    Call this before plotting a figure.

    Parameters
    ----------
    fig_width : float, optional, inches
    fig_height : float,  optional, inches
    columns : {1, 2}
    """

    # code adapted from http://www.scipy.org/Cookbook/Matplotlib/LaTeX_Examples

    # Width and max height in inches for IEEE journals taken from
    # computer.org/cms/Computer.org/Journal%20templates/transactions_art_guide.pdf

    assert (columns in [1, 2])
    current_palette = sns.color_palette('colorblind')
    sns.set_palette(current_palette)

    if fig_width is None:
        fig_width = 3.39 if columns == 1 else 6.9  # width in inches

    if fig_height is None:
        golden_mean = (np.sqrt(5) - 1.0) / 2.0  # Aesthetic ratio
        fig_height = fig_width * golden_mean  # height in inches

    MAX_HEIGHT_INCHES = 8.0
    if fig_height > MAX_HEIGHT_INCHES:
        print("WARNING: fig_height too large:" + fig_height +
              "so will reduce to" + MAX_HEIGHT_INCHES + "inches.")
        fig_height = MAX_HEIGHT_INCHES
    params = {'backend': 'ps',
              'axes.labelsize': 10,  # fontsize for x and y labels (was 10)
              'axes.titlesize': 10,
              'font.size': 10,  # was 10
              'legend.fontsize': 10,  # was 10
              'xtick.labelsize': 10,
              'ytick.labelsize': 10,
              'figure.figsize': [fig_width, fig_height],
              'font.family': 'sans-serif',
              'savefig.dpi': 300,
              'lines.linewidth': 2
              }

    from distutils.spawn import find_executable
    if find_executable('latex'):
        params.update({'text.usetex': True,
              'text.latex.preamble': [r'\usepackage{gensymb}',r'\let\savedegree\degree',r'\let\degree\relax',r'\usepackage{mathabx}','\let\degree\savedegree'],
              })
    matplotlib.rcParams.update(params)

def get_rates(times,senders,NFFT=512,noverlap=256,bin_ms=1.0):
    """
    Receives spike times and sender IDs and return the mean firing rate of the inhibitory neurons
     and the maximal frequency of the population rate
    Args:
        times: spike times
        senders: spike time associated neuron ID
        NFFT: FFT window in datapoints
        noverlap: Overlap window in datapoints
        bin_ms: how many datapoints are one bin

    Returns:
        mean excitatory rate, mean inhibitory rate and maximal frequency of the population firing rate

    """
    exc_times, exc_sender, inh_times, inh_sender = hf.split_in_ex(times, senders)
    inh_rate, inh_bins = hf.bin_pop_rate(inh_times, inh_sender, bin_ms)
    exc_rate, exc_bins = hf.bin_pop_rate(exc_times, exc_sender, bin_ms)

    exc_Pxx, exc_freqs = mlab.psd(exc_rate - np.mean(exc_rate), NFFT=NFFT, Fs=1000. /
                                      (exc_bins[1] - exc_bins[0]), noverlap=noverlap)
    idx=np.argmax(exc_Pxx[exc_freqs>20])
    cut_freqs=exc_freqs[exc_freqs>20]
    max_freq=cut_freqs[idx]
    return np.mean(exc_rate),np.mean(inh_rate),max_freq

def mem_spk_plot(data, times, sender, subplotspec, mem_color, spk_inh_color, spk_exc_color):
    """

    Args:
        data:  membrane potential data
        times: spike times
        sender: spike time associated neuron IDs
        subplotspec: subplot in which to plot
        mem_color: color of membrane potential
        spk_inh_color: color fo the star indicateing spike time for inh neurons
        spk_exc_color: color fo the star indicateing spike time for exc neurons

    Returns:

    """
    id = data[:, 0]
    t = data[:, 1]
    v = data[:, 2]
    t_max = np.max(t)
    unique_sender = np.unique(id)

    gs1 = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=subplotspec,  hspace=0.05)

    in_neurons = unique_sender[unique_sender > 800]
    ex_neurons = unique_sender[unique_sender <= 800]
    if in_neurons.size > 0 and ex_neurons.size > 0:
        in_idx = in_neurons[0]
        ex_idx = ex_neurons[0]

        ax0 = plt.subplot(gs1[0, 0])
        ax1 = plt.subplot(gs1[1, 0])

        ax0.plot(t[id == in_idx], v[id == in_idx], mem_color, linewidth=0.8)
        ax0.plot(times[sender == in_idx - 1], sender[sender == in_idx - 1] * 0,
                 color=spk_inh_color, marker='*', markersize=10, linestyle=' ')
        ax1.plot(t[id == ex_idx], v[id == ex_idx], mem_color, linewidth=0.8)
        ax1.plot(times[sender == ex_idx - 1], sender[sender == ex_idx - 1] * 0,
                 color=spk_exc_color, marker='*', markersize=10, linestyle=' ')
        for ax in [ax0, ax1]:
            ax.set_xlim([t_max - 1000, t_max - 000])
            ax.set_ylim([-100, 100])
            ax.set_yticklabels([-50, 0, 50])
            ax.set_yticks([-50, 0, 50])
            xticks = np.linspace(0, 1000, num=5,
                                 endpoint=True)
        ax1.set_xticks(xticks + t_max - 1000)

        ax1.set_xticklabels(xticks)

        ax0.set_xticks([])
        ax1.set_xlabel('Time [s]')
        ax1.set_ylabel('Membrane Potential [mv]', y=1.1)
    return ax0, ax1


def plot_raster_rate(times, senders, ax01, ax02, incolor='b', excolor='k',bin_ms=1.0,linewidth=1.0):
    """

    Args:
        times: spike times
        sender: spike time associated neuron IDs
        ax01: axis for raster plot
        ax02: axis for population rate
        incolor: inhbiitory color
        excolor: excitatory color
        bin_ms: bin width
        linewidth:

    Returns:

    """

    exc_times, exc_sender, inh_times, inh_sender = hf.split_in_ex(times, senders)

    inh_rate, inh_bins = hf.bin_pop_rate(inh_times, inh_sender, bin_ms)
    exc_rate, exc_bins = hf.bin_pop_rate(exc_times, exc_sender, bin_ms)

    ax01.plot(exc_times, exc_sender, excolor, marker='.', linestyle='', markersize=1)
    ax01.plot(inh_times, inh_sender, incolor, marker='.', linestyle='', markersize=1)

    ax01.set_xlim([np.min(times), np.max(times)])
    ax01.set_ylim([0, 1000])
    ax01.set_xticks([])
    ax01.set_yticks([250, 500, 750])

    # ax01.set_xticklabels(np.linspace(0, 5, num=6,endpoint=True))
    # ax01.set_xlabel('Time [s]')
    ax01.set_ylabel('Neuron Id')

    ax02.plot(inh_bins - np.min(times), inh_rate, incolor,linewidth=linewidth)
    ax02.plot(exc_bins - np.min(times), exc_rate, excolor,linewidth=linewidth)
    ax02.set_xlabel('Time [s]')
    ax02.set_ylabel(r'$f_\mathsf{pop}$ [spk/s]')
    ax02.set_ylim([0, 100])

    ax02.set_yticks([0, 50, 100])
    ax02.set_yticklabels([0, 50, 100])

    ax02.set_xlim([np.min(times) - np.min(times), np.max(times) - np.min(times)])
    xticks = np.linspace(np.min(times) - np.min(times), np.max(times) - np.min(times) + 1, num=6,

                         endpoint=True)
    ax02.set_xticks(xticks)
    ax02.set_xticklabels([0, 1,2,3,4,5])

    ax01.set_yticks([250, 500, 750])


def plot_weights(weights, ax, c='b', bins=40, normed=False, xlim=[0., 10.], ylim=[150., 50000], scale='log', linestyle='-', alpha=0.5):

    """
    Args:
        weights: array of all synatic weights (excitatory)
        ax: ax to plot in
        c: color
        bins: how many bins to plot in
        normed: normalize the freuquency of the histogram
        xlim: set limits fo x axis
        ylim: and y axis
        scale: plot logarithmic or linear
        linestyle: dashed or solid
        alpha: ransparency

    Returns:

    """
    if np.max(weights)>10:
        xlim=[0,np.max(weights)]#there should always be a weight maximal in the resolution 0p1 experiments
    ax.hist(weights, bins=np.arange(xlim[0],xlim[1]+xlim[1]*1./bins,xlim[1]*1./bins), normed=normed, color=c, linestyle=linestyle, alpha=alpha)
    ax.set_ylim(ylim)
    ax.set_xlim(xlim)
    ax.set_xlabel('Synaptic weight [mV]')
    ax.set_ylabel('Frequency')
    ax.set_yscale(scale)


def plot_psd(times, senders, ax, NFFT=512, noverlap=256, xlim=[0., 150.], ylim=[1e-3, 1e2], scale='log', incolor='C0', excolor='C1', linewidth=2):
    """

    Args:
        times: spike times
        sender: spike time associated neuron IDs
        ax: axis to plot in
        NFFT: FFT window in data points
        noverlap: overlap of FFT windows in datapoints
        xlim: set limits fo x axis
        ylim: and y axis
        scale: plot logarithmic or linear
        linestyle: dashed or solid
        incolor: inhibitory color
        excolor: ecitatory color

    Returns:

    """
    exc_times, exc_sender, inh_times, inh_sender = hf.split_in_ex(times, senders)
    if incolor is not None:
        inh_rate, inh_bins = hf.bin_pop_rate(inh_times, inh_sender, 1.)
        inh_Pxx, inh_freqs = mlab.psd(inh_rate - np.mean(inh_rate), NFFT=NFFT, Fs=1000. /
                                      (inh_bins[1] - inh_bins[0]), noverlap=noverlap)
        ax.plot(inh_freqs, inh_Pxx, color=incolor, linewidth=linewidth)
    if excolor is not None:
        exc_rate, exc_bins = hf.bin_pop_rate(exc_times, exc_sender, 1.)
        exc_Pxx, exc_freqs = mlab.psd(exc_rate - np.mean(exc_rate), NFFT=NFFT, Fs=1000. /
                                      (exc_bins[1] - exc_bins[0]), noverlap=noverlap)
        ax.plot(exc_freqs, exc_Pxx, color=excolor, linewidth=linewidth)

    # ax3.plot(bins,freqs,Pxx)
    ax.set_xlabel('Frequency [Hz]')
    ax.set_ylabel('Power [a.u.]')
    ax.set_yscale(scale)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_yticks([])


def return_NTL(groupfile):
    if os.path.getsize(groupfile) < 422099208 * 1.1:
        groups = hf.read_group_file(groupfile)
    else:
        f = open(groupfile)
        groups = ijson.items(f, "item")
    N_list = []
    L_list = []
    T_list = []
    i = 0

    for i, g in enumerate(groups):
        if 'Failed' in g.keys():
            return False
        times, senders = hf.get_t_s(g)

        N_list.append(int(g["N_fired"]))

        T_list.append(max(times))  # time span

        L_list.append(int(g["L_max"]))  # longest path
    return N_list, T_list, L_list
